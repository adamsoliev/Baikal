-----------------------------------------------------------------------------
DESCRIPTION OF CURRENT STATE: source -> tokens -> AST -> RISC-V
-----------------------------------------------------------------------------
Goals
    learning about compiler implementation in general and about code generation in particular 
    (how high level structures are translated to assembly) 

Minimal memory management
    it usually callocs away, only freeing when necessary (e.g., register names)

Minimal symbol management
    it uses a single hash table with string/symbol key-value pair. symbol is a struct that has value and offset fields

Scanning
    except keywords/numbers, which are handled using library functions, it is a hand-coded scanner that examines 
    the source char by char, generating respective tokens

Parsing 
    recursive descend parser; all EXPRESSIONS and STATEMENTS are implemented; binary expressions are handled using 
    a table-driven approach, which is both efficient and less verbose. missing major pieces are (more complex) 
    DECLARATIONS, TYPES except INT (type are represented using bit-string) and nice error messages/graceful handling  

AST/Semantic analysis
    again, could be improved. declaration/statement combo is handled via one struct type, which simplified parsing and 
    aided in the codegen. type checking is left out since the only handled type is INT. some name resolution is enforced 
    by the hash table 

Codegen
    high level constructs in AST are translated as straighforwardly as it possible  
-----------------------------------------------------------------------------


**************************************************************************************************
Parsing
**************************************************************************************************

-----------------------------------------------------------------------------
prec    assoc   purpose     op
-----------------------------------------------------------------------------
1       left                ,
2       right   asgn        =, *=, /=, +=, -=, %=, <<=, >>=, &=, ^=, |=
3       right   cond        ? :
4       left    logor       ||
5       left    logand      &&
6       left    inclor      |
7       left    exclor      ^
8       left    and         &
9       left    equal       ==, !=
10      left    rel         <, >, <=, >=
11      left    shift       <<, >>
12      left    add         +, -
13      left    mul         *, /, %
        left    cast        
14      left    unary       ++, --, &, *, -, ~, !
15      left    postfix     ++, --, ->, .
                primary
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
stmt                                             Edecl fields
-----------------------------------------------------------------------------
label_stmt
    ident ':' stmt                              | value then
    'case' expr ':' stmt                        | cond then
    'default' ':' stmt                          | then

compound_stmt
    '{' block '}'                               | body

expression_stmt
    expr ';'                                    | value 

selection_stmt
    'if' '(' expr ')' stmt                      | cond then
    'if' '(' expr ')' stmt 'else' stmt          | cond then els
    'switch' '(' expr ')' stmt                  | cond then

iteration_stmt
    'while' '(' expr ')' stmt                   | cond then
    'do' stmt 'while' '(' expr ')' ';'          | then cond
    'for' '(' expr ';' expr ';' expr ')' stmt   | init cond inc then
    'for' '(' decl expr ';' expr ')' stmt       | init cond inc then

jump_stmt
    'goto' ident ';'                            | value
    'continue' ';'                              | 
    'break' ';'                                 | 
    'return' expr ';'                           | value
-----------------------------------------------------------------------------


**************************************************************************************************
RISC-V ASSEMBLY
**************************************************************************************************

-------------------------------------------------------------------
1. Put parameters in a place where the procedure can access them.
x10 - x17       : param registers
-------------------------------------------------------------------
2. Transfer control to the procedure.
jal x1, lable   : jump to label and write return address to x1
-------------------------------------------------------------------
3. Acquire the storage resources needed for the procedure.
allocate space in stack and move stack/frame pointers accordingly
-------------------------------------------------------------------
4. Perform the desired task.
-------------------------------------------------------------------
5. Put the result value in a place where the calling program can access it.
x10 - x17       : param registers
-------------------------------------------------------------------
6. Return control to the point of origin, since a procedure can be called from
several points in a program.
jalr x0, 0(x1)  : return from a function
-------------------------------------------------------------------

Register        ABI Name        Description             Saver           Preserved on call?
x0              zero            Zero constant           —               n.a
x1              ra              Return address          Callee          yes
x2              sp              Stack pointer           Callee          yes
x3              gp              Global pointer          —               yes
x4              tp              Thread pointer          —               yes
x5-x7           t0-t2           Temporaries             Caller          no
x8              s0/fp           Saved/frame pointer     Callee          yes
x9              s1              Saved register          Callee          yes
x10-x11         a0-a1           Fn args/return values   Caller          no
x12-x17         a2-a7           Fn args                 Caller          no
x18-x27         s2-s11          Saved registers         Callee          yes
x28-x31         t3-t6           Temporaries             Caller          no


Convention
1. Registers 
        ABI     Preserved on call?
        zero    yes
        ra      yes
        sp      yes
        gp      yes
        tp      yes
        t0-t6   no      Temporaries
        s0-s11  yes     Saved 
        a0-a7   no      Args/Return
2. Function calls
        function calls are made using
                jal ra label     (jal label)
                jalr ra rd imm   (jalr rd when imm is 0)
                both essentially do:
                        ra = PC + 4
                        PC += label offset || rd + imm
        * standard jump in a loop uses x0 instead of ra (doesn't save return address)
                jal x0 label     (j label)
                jalr x0 rd imm   (jr rd when imm is 0)
3. Entering/exiting a function (prologue/epilogue)
        • sp will be preserved (unless we store return values on the stack)
        • All s registers will be preserved
        • Function will return to the address stored in ra, assuming no abnormal execution

        • prologue
        Decrement sp by number of used 'saved registers' + local variable space
        Store any saved registers used
        Store ra if a function call is made        

        • epilogue
        Reload any saved registers used
        Reload ra (if necessary)
        Increment sp back to previous value
        Jump back to return address

* Using Convention to Debug
        • Check that you stored ra properly. For recursion make sure you link ra
        for each recursive call. You can test this by putting a break point at the
        end of the epilogue and seeing where you return.
        • Check that you don’t use any t registers after a function call.
        • Check that sp enters and exits with the same value.
        • Check the number of times you enter the prologue equals the number of times you enter the epilogue.
        • Make sure you restore every register you modified.


ACTIVATION RECORD
-----------------------------------------------------------------------------
 fp ->   -----------
        | incoming  |   first 8 args are passed in a0-a7
        |   args    |   rest are passed here
         -----------
        |  ra (old) |   so that we can return
         -----------
        |  fp (old) |   so that we have idea of prev AR's fp
         -----------|
        |   s1-s11  |   so that we have some regs preserved during funcall
         -----------|
        |   locals  |   for local calculations
 sp ->   -----------
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
GENERAL NOTES 
-----------------------------------------------------------------------------
INSTRUCTION SELECTION
  converting from tree structured IR to sequence of instructions
    – create temporary locations to store values
    – choose which operations 
      • can combine or breakup original operations
  match portions of tree and convert to triple

REGISTER ALLOCATION
  map important vars & temps in assembly to either registers or slots in activation frame by
    - assignment (assign to vars & temps registers)
    - spilling (if can't assign to a register, assign a slot in activation frame)
    - coalescing (eliminate moves a<->b and map both a&b to the same location)

  solutions
    - interference graph -> attempt register allocation by searching for a K-coloring
      * NP-complete but a linear-time simplification algorithm works well in practice
  
  rules
    vars & temps with interfering live ranges may not be assigned to the same machine register

STATIC SINGLE ASSIGNMENT
  each name is assigned in only one location
  simplifies many optimizations