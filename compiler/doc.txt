**************************************************************************************************
Parsing
**************************************************************************************************

-----------------------------------------------------------------------------
prec    assoc   purpose     op
-----------------------------------------------------------------------------
1       left                ,
2       right   asgn        =, *=, /=, +=, -=, %=, <<=, >>=, &=, ^=, |=
3       right   cond        ? :
4       left    logor       ||
5       left    logand      &&
6       left    inclor      |
7       left    exclor      ^
8       left    and         &
9       left    equal       ==, !=
10      left    rel         <, >, <=, >=
11      left    shift       <<, >>
12      left    add         +, -
13      left    mul         *, /, %
        left    cast        
14      left    unary       ++, --, &, *, -, ~, !
15      left    postfix     ++, --, ->, .
                primary
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
stmt                                             Edecl fields
-----------------------------------------------------------------------------
label_stmt
    ident ':' stmt                              | value then
    'case' expr ':' stmt                        | cond then
    'default' ':' stmt                          | then

compound_stmt
    '{' block '}'                               | body

expression_stmt
    expr ';'                                    | value 

selection_stmt
    'if' '(' expr ')' stmt                      | cond then
    'if' '(' expr ')' stmt 'else' stmt          | cond then els
    'switch' '(' expr ')' stmt                  | cond then

iteration_stmt
    'while' '(' expr ')' stmt                   | cond then
    'do' stmt 'while' '(' expr ')' ';'          | then cond
    'for' '(' expr ';' expr ';' expr ')' stmt   | init cond inc then
    'for' '(' decl expr ';' expr ')' stmt       | init cond inc then

jump_stmt
    'goto' ident ';'                            | value
    'continue' ';'                              | 
    'break' ';'                                 | 
    'return' expr ';'                           | value
-----------------------------------------------------------------------------


**************************************************************************************************
RISC-V ASSEMBLY
**************************************************************************************************

-------------------------------------------------------------------
1. Put parameters in a place where the procedure can access them.
x10 - x17       : param registers
-------------------------------------------------------------------
2. Transfer control to the procedure.
jal x1, lable   : jump to label and write return address to x1
-------------------------------------------------------------------
3. Acquire the storage resources needed for the procedure.
allocate space in stack and move stack/frame pointers accordingly
-------------------------------------------------------------------
4. Perform the desired task.
-------------------------------------------------------------------
5. Put the result value in a place where the calling program can access it.
x10 - x17       : param registers
-------------------------------------------------------------------
6. Return control to the point of origin, since a procedure can be called from
several points in a program.
jalr x0, 0(x1)  : return from a function
-------------------------------------------------------------------

Register        ABI Name        Description             Saver           Preserved on call?
x0              zero            Zero constant           —               n.a
x1              ra              Return address          Callee          yes
x2              sp              Stack pointer           Callee          yes
x3              gp              Global pointer          —               yes
x4              tp              Thread pointer          —               yes
x5-x7           t0-t2           Temporaries             Caller          no
x8              s0/fp           Saved/frame pointer     Callee          yes
x9              s1              Saved register          Callee          yes
x10-x11         a0-a1           Fn args/return values   Caller          no
x12-x17         a2-a7           Fn args                 Caller          no
x18-x27         s2-s11          Saved registers         Callee          yes
x28-x31         t3-t6           Temporaries             Caller          no


Convention
1. Registers 
        ABI     Preserved on call?
        zero    yes
        ra      yes
        sp      yes
        gp      yes
        tp      yes
        t0-t6   no      Temporaries
        s0-s11  yes     Saved 
        a0-a7   no      Args/Return
2. Function calls
        function calls are made using
                jal ra label     (jal label)
                jalr ra rd imm   (jalr rd when imm is 0)
                both essentially do:
                        ra = PC + 4
                        PC += label offset || rd + imm
        * standard jump in a loop uses x0 instead of ra (doesn't save return address)
                jal x0 label     (j label)
                jalr x0 rd imm   (jr rd when imm is 0)
3. Entering/exiting a function (prologue/epilogue)
        • sp will be preserved (unless we store return values on the stack)
        • All s registers will be preserved
        • Function will return to the address stored in ra, assuming no abnormal execution

        • prologue
        Decrement sp by number of used 'saved registers' + local variable space
        Store any saved registers used
        Store ra if a function call is made        

        • epilogue
        Reload any saved registers used
        Reload ra (if necessary)
        Increment sp back to previous value
        Jump back to return address

* Using Convention to Debug
        • Check that you stored ra properly. For recursion make sure you link ra
        for each recursive call. You can test this by putting a break point at the
        end of the epilogue and seeing where you return.
        • Check that you don’t use any t registers after a function call.
        • Check that sp enters and exits with the same value.
        • Check the number of times you enter the prologue equals the number of times you enter the epilogue.
        • Make sure you restore every register you modified.


ACTIVATION RECORD
-----------------------------------------------------------------------------
 fp ->   -----------
        | incoming  |   first 8 args are passed in a0-a7
        |   args    |   rest are passed here
         -----------
        |  ra (old) |   so that we can return
         -----------
        |  fp (old) |   so that we have idea of prev AR's fp
         -----------|
        |   s1-s11  |   so that we have some regs preserved during funcall
         -----------|
        |   locals  |   for local calculations
 sp ->   -----------
-----------------------------------------------------------------------------


source, tokens, trees, and lists trees

goals - learning about compiler implementation in general and about code generation in particular 
(how high level structures are translated to assembly) simplicity

Compilers cooperate with processors, linkers, loaders, debuggers, assemblers, and operating system

Miniamal storage management
    it usually callocs away, only freeing when necessary (e.g., register names)

Symbol Management
    the lexical analyzer adds identifiers to the identifier table, and the parser adds type
    information to these identifiers. The code generators add target-specific
    data to symbol-table entries    

    attributes of identifier that names a local variable might include variable's type, its location 
    in a stack frame for the procedure in which it is declared, and its storage class

    scope or visibility rules imposed by the ANSI C standard

    There are three separate name spaces for labels, tags, and identifiers, and, for each structure or union,
    there is a separate name space for its members. For each name space, there can be only one visible identifier 
    of a given name at any point in the program. There can, however, be more than one visible identifier 
    at any point in the program if each such identifier is in a different name space

    Roughly speaking, there is a separate symbol table for each name
    space, and symbol tables themselves handle scope. 1 cc also uses sepa-
    rate symbol tables for unscoped collections, like constants

    struct Symbol => struct Table =>   