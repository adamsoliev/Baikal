-----------------------------------------------------------------------------
prec    assoc   purpose     op
-----------------------------------------------------------------------------
1       left                ,
2       right   asgn        =, *=, /=, +=, -=, %=, <<=, >>=, &=, ^=, |=
3       right   cond        ? :
4       left    logor       ||
5       left    logand      &&
6       left    inclor      |
7       left    exclor      ^
8       left    and         &
9       left    equal       ==, !=
10      left    rel         <, >, <=, >=
11      left    shift       <<, >>
12      left    add         +, -
13      left    mul         *, /, %
        left    cast        
14      left    unary       ++, --, &, *, -, ~, !
15      left    postfix     ++, --, ->, .
                primary
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
stmt                                             Edecl fields
-----------------------------------------------------------------------------
label_stmt
    ident ':' stmt                              | value then
    'case' expr ':' stmt                        | cond then
    'default' ':' stmt                          | then

compound_stmt
    '{' block '}'                               | body

expression_stmt
    expr ';'                                    | value 

selection_stmt
    'if' '(' expr ')' stmt                      | cond then
    'if' '(' expr ')' stmt 'else' stmt          | cond then els
    'switch' '(' expr ')' stmt                  | cond then

iteration_stmt
    'while' '(' expr ')' stmt                   | cond then
    'do' stmt 'while' '(' expr ')' ';'          | then cond
    'for' '(' expr ';' expr ';' expr ')' stmt   | init cond inc then
    'for' '(' decl expr ';' expr ')' stmt       | init cond inc then

jump_stmt
    'goto' ident ';'                            | value
    'continue' ';'                              | 
    'break' ';'                                 | 
    'return' expr ';'                           | value
-----------------------------------------------------------------------------


A Survey of Compiler Testing
https://sci-hub.ru/https://dl.acm.org/doi/fullHtml/10.1145/3363562

Previous interesting compilers
https://en.wikipedia.org/wiki/PL/8

COMPILER TESTING
https://stackoverflow.com/questions/1104922/compiler-test-cases-or-how-to-test-a-compiler
https://gcc.gnu.org/onlinedocs//gccint/C-Tests.html
https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_compiler_validations.html
https://users.cs.utah.edu/~regehr/papers/pldi11-preprint.pdf

https://github.com/c-testsuite/c-testsuite/tree/master
https://github.com/nlsandler/write_a_c_compiler
https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests
https://github.com/csmith-project/creduce [reduce large C/C++ programs into small ones that have the same behavior]
https://github.com/csmith-project/csmith [random generator of C programs]

Challenges
1. One challenge is the lack of a formal specification of what exactly a compiler is supposed to do
2. Another challenge for testing is the semantic richness of the input and output languages that compilers deal with
3. A third important challenge is that compilers have various options and features

Properties that simplify the problem of validating their correctness
1. One such property is that the inputs to compilers are written in a programming language, i.e., the space of possible inputs is clearly defined by the language grammar
2. Another property that eases compiler testing is that the semantics of the source language are usually specified
3. The fact that for most popular programming languages, there are multiple supposedly equivalent implementations, which compiler testing can exploit as an oracle for differential testing 


-------------------------------------------------------------------
1. Put parameters in a place where the procedure can access them.
x10 - x17       : param registers
-------------------------------------------------------------------
2. Transfer control to the procedure.
jal x1, lable   : jump to label and write return address to x1
-------------------------------------------------------------------
3. Acquire the storage resources needed for the procedure.
allocate space in stack and move stack/frame pointers accordingly
-------------------------------------------------------------------
4. Perform the desired task.
-------------------------------------------------------------------
5. Put the result value in a place where the calling program can access it.
x10 - x17       : param registers
-------------------------------------------------------------------
6. Return control to the point of origin, since a procedure can be called from
several points in a program.
jalr x0, 0(x1)  : return from a function
-------------------------------------------------------------------

Register        ABI Name        Description             Saver           Preserved on call?
x0              zero            Zero constant           —               n.a
x1              ra              Return address          Callee          yes
x2              sp              Stack pointer           Callee          yes
x3              gp              Global pointer          —               yes
x4              tp              Thread pointer          —               yes
x5-x7           t0-t2           Temporaries             Caller          no
x8              s0/fp           Saved/frame pointer     Callee          yes
x9              s1              Saved register          Callee          yes
x10-x11         a0-a1           Fn args/return values   Caller          no
x12-x17         a2-a7           Fn args                 Caller          no
x18-x27         s2-s11          Saved registers         Callee          yes
x28-x31         t3-t6           Temporaries             Caller          no


Convention
1. Registers 
        ABI     Preserved on call?
        zero    yes
        ra      yes
        sp      yes
        gp      yes
        tp      yes
        t0-t6   no      Temporaries
        s0-s11  yes     Saved 
        a0-a7   no      Args/Return
2. Function calls
        function calls are made using
                jal ra label     (jal label)
                jalr ra rd imm   (jalr rd when imm is 0)
                both essentially do:
                        ra = PC + 4
                        PC += label offset || rd + imm
        * standard jump in a loop uses x0 instead of ra (doesn't save return address)
                jal x0 label     (j label)
                jalr x0 rd imm   (jr rd when imm is 0)
3. Entering/exiting a function (prologue/epilogue)
        • sp will be preserved (unless we store return values on the stack)
        • All s registers will be preserved
        • Function will return to the address stored in ra, assuming no abnormal execution

        • prologue
        Decrement sp by number of used 'saved registers' + local variable space
        Store any saved registers used
        Store ra if a function call is made        

        • epilogue
        Reload any saved registers used
        Reload ra (if necessary)
        Increment sp back to previous value
        Jump back to return address

* Using Convention to Debug
        • Check that you stored ra properly. For recursion make sure you link ra
        for each recursive call. You can test this by putting a break point at the
        end of the epilogue and seeing where you return.
        • Check that you don’t use any t registers after a function call.
        • Check that sp enters and exits with the same value.
        • Check the number of times you enter the prologue equals the number of times you enter the epilogue.
        • Make sure you restore every register you modified.
