XV6

RISC-V CPU modes: machine, supervisor and user

Initial setup
    boot loader in ROM loads kernel into memory at 0x80000000
        first set of instrs in .text of kernel are specified by linker ENTRY command (_entry)
    _entry 
        set up stack
        call C code at start
    start
        set mstatus
        set mepc to main's address
        set satp to 0 (turn off virtual address translation)
        delegate all interrupts/exceptions to supervisor mode
        turn on clock chip
        call mret (which jumps to address at mepc)
    main
        initialize devices and subsystems
        create a process and return to user space in that process 
        start shell on console
        system is up

Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.

----------------------------------------------------------------
1. OS INTERFACES
----------------------------------------------------------------

----------------------------------------------------------------
2. OS ORGANIZATION
----------------------------------------------------------------

----------------------------------------------------------------
3. PAGE TABLES
----------------------------------------------------------------

----------------------------------------------------------------
4. TRAPS AND SYSCALLS
----------------------------------------------------------------
  Syscall, exception (illegal action), interrupt (device I/O)
  
  All are transparently handled in kernel
  
  RISC-V trap machinery (for traps handled in supervisor mode)
    stvec     address of trap handler
    sepc      where PC is saved before jumping to trap handler
    scause    reason for trap
    sscratch  helper register to save user registers
    sstatus   SIP bit - whether device interrupts are on/off; SPP bit - whether trap came from user/supervisor mode

  while executing user code
    ------------------------------------------
    uservec (in trampoline page) -> usertrap (trap.c)
    ------------------------------------------
      uservec   - save regs in & retrieve trap handling info from trapframe page; switch page tables; call usertrap
      usertrap  - determine cause of the trap, process it and return
        modify stvec, save sepc, (syscall | devintr | error) 
    ------------------------------------------
    usertrapret (trap.c) -> userret (in trampoline page)
    ------------------------------------------
      usertrapret - restore control registers to prep for a future trap;
        point stvec to uservec, prepping trapframe fields, set sepc to prev saved
        user pc; call userret
      userret     - switch page tables; restore user regs; execute sret to return to user space

  while executing kernel space
    ------------------------------------------
    kernelvec -> kerneltrap
    ------------------------------------------
      kernelvec   - save regs into a respective kernel stack
      kerneltrap  - save control regs; (devinstr | error)

----------------------------------------------------------------
5. INTERRUPTS AND DEVICE DRIVERS
----------------------------------------------------------------
  consoleinit - configure UART hardware to generate interrupts (on receive and transmit)
  consoleread - wait for inputs to arrive (via interrupts) & be buffered in
  cons.buf; copy that to user space; return to user process

    shell -> read() -> fileread() -> devsw[CONSOLE].read() -> consoleread() -> wait until waken by consoleintr
    (uservec | kernelvec) -> (usertrap | kerneltrap) -> devintr -> uartintr -> consoleintr -> collect input and wake up consoleread if there is one
    
    shell -> write() -> filewrite() -> devsw[CONSOLE].write() -> consolewrite() -> uartputc() -> uartstart() 
                                                                                  uartintr() -> uartstart() 
  
  NS16450 UART
  https://www.lammertbies.nl/comm/info/serial-uart

----------------------------------------------------------------
6. LOCKING
----------------------------------------------------------------
  Kernel data structures need to be protected from concurrent changes, such as in
    Multiprocessor parallelism
    Thread switching
    Interrupts
  
  Lock is a simple correct solution but is bad for performance

  In some cases multiple locks are needed to protect a code path. In such cases,
  lock acquire/release ordering matters. Otherwise, deadlocks might arise. By 
  defintion, these lock chains need to be global and honoring such a global ordering
  might be difficult programmatically. 

  Re-entrant locks??

  Protecting data that is used by both threads and interrupt handlers should be 
  done with care; otherwise, the thread holding a lock for data might be 
  interrupted and the corresponding interrupt handler might also try to acquire the 
  same lock. That lock won't be released because it can only be released by the
  thread but that thread won't continue running unless the interrupt handler returns; 
  the handler won't return because it can't acquire the lock - deadlock. 

  Memory ordering should be turn-off around critical sections protected by locks

  Sleeplock is used in longer waiting cases; it allows yielding and interrupts, 
  allowing CPU to be used efficiently while the process waits (e.g., for disk I/O). 
  Important implementation detail about sleeplocks is just before going to sleep,
  CPU is yielded atomically and lock is released. 

  Spinlocks (for short critical sections)
  Sleeplocks (for lengthy operations)

----------------------------------------------------------------
7. SCHEDULING
----------------------------------------------------------------

----------------------------------------------------------------
8. FILE SYSTEM
----------------------------------------------------------------
  File descriptor - abstract many Unix resources using the file system interface
  Pathname        - provide hierarchical path names & resolve them using recursive lookup
  Directory       - implement each dir as a special kind of inode
  Inode           - provide individual files (inode with unique i-number & some blocks holding the file's data)
  Logging         - wrap updates to several blocks in a transaction
  Buffer cache    - cache blocks and synchronize access to them
  Disk            - read/write blocks on virtio hard drive

----------------------------------------------------------------
9. CONCURRENCY REVISITED
----------------------------------------------------------------

