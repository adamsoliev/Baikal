XV6

Initial setup
    boot loader in ROM loads kernel into memory at 0x80000000
        first set of instrs in .text of kernel are specified by linker ENTRY command (_entry)
    _entry 
        set up stack
        call C code at start
    start
        set mstatus
        set mepc to main's address
        set satp to 0 (turn off virtual address translation)
        delegate all interrupts/exceptions to supervisor mode
        turn on clock chip
        call mret (which jumps to address at mepc)
    main
        initialize devices and subsystems
        create a process and return to user space in that process 
        start shell on console
        system is up

Syscalls
  read
      read() -> fileread() -> devsw[CONSOLE].read() -> consoleread() -> wait
      until cons.buf is filled up by consoleintr(), which also echoes chars back
      to user -> copy to user-space dst -> return to user process

  write
      write() -> filewrite() -> devsw[CONSOLE].write() -> consolewrite() ->
      uartputc() -> uartstart() -> send if THR has space; otherwise return, will
      be called again via interrupt when THR is ready to accept [uartintr() -> uartstart()]

  // console related traps <-> consoleintr()
  trap handler -> devintr() -> PLIC via scause -> uartintr() -> consoleintr()

TRAPS - events that cause CPU to set aside ordinary execution of instructions
  types: syscall, exception, interrupt
  
  transparent handling of traps (save state -> handle trap -> restore state)

  handling proceeds in four stages
    hardware action taken by RISC-V CPU
    some assembly instructions that prepare the way for kernel C code
    C function that decides what to do with the trap
    syscall or device-driver routine

  separate code for three distinct cases: 
    traps from used space: syscall, device interrupt or exception
      uservec() -> usertrap() -> usertrapret() -> userret()
    traps from kernel space: device interrupt or exception
    timer interrupts
  
Memory managemenet
  page-grained allocation
  byte-grained allocation
  managing mmu

NS16450 UART
https://www.lammertbies.nl/comm/info/serial-uart

----------------------------------------------------------------
XV6 Notes
----------------------------------------------------------------
Process and memory: instructions, data, and stack and kstack

I/O and file descriptors

Pipes

File system: inode, dirs, names, 

Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.

RISC-V CPU modes: machine, supervisor and user

Traps and syscalls
  Syscall, exception (illegal action), interrupt (device I/O)
  
  All are transparently handled in kernel
  
  RISC-V trap machinery (for traps handled in supervisor mode)
    stvec     address of trap handler
    sepc      where PC is saved before jumping to trap handler
    scause    reason for trap
    sscratch  helper register to save user registers
    sstatus   SIP bit - whether device interrupts are on/off; SPP bit - whether trap came from user/supervisor mode

  while executing user code
    ------------------------------------------
    uservec (in trampoline page) -> usertrap (trap.c)
    ------------------------------------------
      uservec   - save regs in & retrieve trap handling info from trapframe page; switch page tables; call usertrap
      usertrap  - determine cause of the trap, process it and return
        modify stvec, save sepc, (syscall | devintr | error) 
    ------------------------------------------
    usertrapret (trap.c) -> userret (in trampoline page)
    ------------------------------------------
      usertrapret - restore control registers to prep for a future trap;
        point stvec to uservec, prepping trapframe fields, set sepc to prev saved
        user pc; call userret
      userret     - switch page tables; restore user regs; execute sret to return to user space

  while executing kernel space
    ------------------------------------------
    kernelvec -> kerneltrap
    ------------------------------------------
      kernelvec   - save regs into a respective kernel stack
      kerneltrap  - save control regs; (devinstr | error)

Interrupts and device drivers
  consoleinit - configure UART hardware to generate interrupts (on receive and transmit)
  consoleread - wait for inputs to arrive (via interrupts) & be buffered in
  cons.buf; copy that to user space; return to user process

    shell -> read syscall -> consoleread -> sleep until waken by consoleintr
    (uservec | kernelvec) -> (usertrap | kerneltrap) -> devintr -> uartintr -> consoleintr -> collect input and wake up consoleread if there is one
    
    shell -> write -> uartputc -> uartstart
                      uartintr -> uartstart 

File system
  File descriptor - abstract many Unix resources using the file system interface
  Pathname        - provide hierarchical path names & resolve them using recursive lookup
  Directory       - implement each dir as a special kind of inode
  Inode           - provide individual files (inode with unique i-number & some blocks holding the file's data)
  Logging         - wrap updates to several blocks in a transaction
  Buffer cache    - cache blocks and synchronize access to them
  Disk            - read/write blocks on virtio hard drive




