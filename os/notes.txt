XV6

----------------------------------------------------------------
1. OS INTERFACES (abstractions that STOOD THE TEST OF TIME)
----------------------------------------------------------------
Process 
  user-space memory (instrs, data, stack) and per-process state private to kernel

File descriptor
  int representing a kernel-managed object that a process reads/writes;
  that object is often referred to as a 'file' (could be file|dir|device|pipe)

  the xv6 kernel uses the file descriptor as an index into a per-process table, 
  so that every process has a private space of file descriptors starting at zero
  
Pipes
  kernel buffer exposed to processes as a pair of file descriptors, 
  one for reading and one for writing; pipes provide a way for processes to communicate

File system
  data files and directories, which contain named references to data files and other dirs

  struct inode (file|dir|device)
    file    - inode with data
    dir     - inode with a sequence of dirent structs, each of which
              {
                int inum;     // ref to file's inode (unique to each file)
                char name[x]; // file's name (also called 'link')
              }
    device  - inode with device address 

  inode is in-memory copy of dinode, which is on disk

----------------------------------------------------------------
2. OS ORGANIZATION
----------------------------------------------------------------
fundamentally, xv6 should provide multiplexing, isolation, and interaction 
between proc_x vs proc_y and between processes vs kernel
  
RISC-V has user, supervisor and machine modes; xv6 uses/extends this to achieve
above goals

Process - unit of isolation
  The mechanisms used by the kernel to implement processes include 
  the user/supervisor mode flag, address spaces, and time-slicing of threads

  kernel maintains many pieces of state for each process in a struct proc

  xv6 uses per-process page table to give each process its own address space (p->pagetable)
    +-------------------+ 0x3fffffffff (2^38 - 1)
    | trampoline        |
    +-------------------+
    | trapframe         |
    +-------------------+
    |                   |
    | heap              |
    |                   |
    +-------------------+
    | user stack        |
    +-------------------+
    | user text & data  |
    +-------------------+ 0

  xv6 uses trampoline/trapframe to transition into the kernel and back; 
  former contains the code to transition in and out of the kernel;
  latter is necessary to save/restore the state of the user process

  each process has two stacks: a user stack (in user address space) and 
  a kernel stack (in kernel address space); ustack for process' instrs;
  p->kstack for kernel to handle process' syscalls or interrupts that happen 
  while the process is executing

  starting xv6
    boot loader in ROM loads kernel into memory at 0x80000000
        first set of instrs in .text of kernel are specified by linker ENTRY command (_entry)
    -----------------
    machine mode
    -----------------
    _entry 
        set up stack
        call C code at start
    start
        set mstatus
        set mepc to main's address
        set satp to 0 (turn off virtual address translation)
        delegate all interrupts/exceptions to supervisor mode
        program clock chip for timer interrupts
        call mret (which jumps to address at mepc)
    -----------------
    supervisor mode
    -----------------
    main
        initialize devices and subsystems
        create the 1st process and make it 'RUNNABLE'
        scheduler picks that process up and runs it, entering user mode
    -----------------
    user mode
    -----------------
        make a syscall exec with args 
    -----------------
    supervisor mode
    -----------------
        in kernel, handle exec syscall, which replaces memory/regs of 
        current process with a new program ('/init')
    -----------------
    user mode
    -----------------
        return to user space in '/init' process
        '/init' creates a new console device with file descriptors 0,1,2 opened
        '/init' starts shell on the console
    system is up

----------------------------------------------------------------
3. PAGE TABLES
----------------------------------------------------------------

----------------------------------------------------------------
4. TRAPS AND SYSCALLS
----------------------------------------------------------------
  Syscall, exception (illegal action), interrupt (device I/O)
  
  All are transparently handled in kernel
  
  RISC-V trap machinery (for traps handled in supervisor mode)
    stvec     address of trap handler
    sepc      where PC is saved before jumping to trap handler
    scause    reason for trap
    sscratch  helper register to save user registers
    sstatus   SIP bit - whether device interrupts are on/off; SPP bit - whether trap came from user/supervisor mode

  while executing user code
    ------------------------------------------
    uservec (in trampoline page) -> usertrap (trap.c)
    ------------------------------------------
      uservec   - save regs in & retrieve trap handling info from trapframe page; switch page tables; call usertrap
      usertrap  - determine cause of the trap, process it and return
        modify stvec, save sepc, (syscall | devintr | error) 
    ------------------------------------------
    usertrapret (trap.c) -> userret (in trampoline page)
    ------------------------------------------
      usertrapret - restore control registers to prep for a future trap;
        point stvec to uservec, prepping trapframe fields, set sepc to prev saved
        user pc; call userret
      userret     - switch page tables; restore user regs; execute sret to return to user space

  while executing kernel space
    ------------------------------------------
    kernelvec -> kerneltrap
    ------------------------------------------
      kernelvec   - save regs into a respective kernel stack
      kerneltrap  - save control regs; (devinstr | error)

----------------------------------------------------------------
5. INTERRUPTS AND DEVICE DRIVERS
----------------------------------------------------------------
  consoleinit - configure UART hardware to generate interrupts (on receive and transmit)
  consoleread - wait for inputs to arrive (via interrupts) & be buffered in
  cons.buf; copy that to user space; return to user process

    shell -> read() -> fileread() -> devsw[CONSOLE].read() -> consoleread() -> wait until waken by consoleintr
    (uservec | kernelvec) -> (usertrap | kerneltrap) -> devintr -> uartintr -> consoleintr -> collect input and wake up consoleread if there is one
    
    shell -> write() -> filewrite() -> devsw[CONSOLE].write() -> consolewrite() -> uartputc() -> uartstart() 
                                                                                  uartintr() -> uartstart() 
  
  NS16450 UART
  https://www.lammertbies.nl/comm/info/serial-uart

----------------------------------------------------------------
6. LOCKING
----------------------------------------------------------------
  Kernel data structures need to be protected from concurrent changes, such as in
    Multiprocessor parallelism
    Thread switching
    Interrupts
  
  Lock is a simple correct solution but is bad for performance

  In some cases multiple locks are needed to protect a code path. In such cases,
  lock acquire/release ordering matters. Otherwise, deadlocks might arise. By 
  defintion, these lock chains need to be global and honoring such a global ordering
  might be difficult programmatically. 

  Re-entrant locks??

  Protecting data that is used by both threads and interrupt handlers should be 
  done with care; otherwise, the thread holding a lock for data might be 
  interrupted and the corresponding interrupt handler might also try to acquire the 
  same lock. That lock won't be released because it can only be released by the
  thread but that thread won't continue running unless the interrupt handler returns; 
  the handler won't return because it can't acquire the lock - deadlock. 

  Memory ordering should be turn-off around critical sections protected by locks

  Sleeplock is used in longer waiting cases; it allows yielding and interrupts, 
  allowing CPU to be used efficiently while the process waits (e.g., for disk I/O). 
  Important implementation detail about sleeplocks is just before going to sleep,
  CPU is yielded atomically and lock is released. 

  Spinlocks (for short critical sections)
  Sleeplocks (for lengthy operations)

----------------------------------------------------------------
7. SCHEDULING
----------------------------------------------------------------
  thread - one serial execution
    pc, regs, stack

  xv6 multiplexes in 
    sleep/wakeup mechamism
    periodic switch to copy with processes that computer for long periods
  
  issues
    how to do it? 
    how to do it transparently to user? 
    locking of process data structures to avoid races between different CPUs? 
    how to handle switching user/supervisor resources? 
    how do avoid races that result in loss of wakeup signals?
  
  context switching
    user stack #1 -> kstack #1 -> scheduler context of the core -> kstack #2 -> user stack #2
  
  scheduling
    important thing to understand here is that sched and scheduler intentionally transfer
    control to each other via thread switch. 
      A kernel thread gives up CPU in sched 
      Control is transfered to scheduler 
      Scheduler returns in another kernel thread's sched call
  
  sleep/wakeup

    Typical usage of sleep/wakeup
    -----------------------------------------------------------------------------------
    Thread1
    ------------
    acquire(cond_lock);
    while (cond) 
      sleep(&cond, &cond_lock);  // &cond is an address and just used as a channel
    release(cond_lock);

    Thread2
    ------------
    acquire(cond_lock);
    cond += change;
    wakeup(&cond);
    release(cond_lock);
    -----------------------------------------------------------------------------------
    
    going into sleep, we need to have condition_lock. To put the current process to sleep (change its state), 
    we acquire the process_lock inside sleep; right after, we release the condition_lock, 
    so that some other thread can acquire that condition_lock and change the condition. 
    That thread then waits spinning, waiting to acquire the process_lock that sleep holds. Once 
    sleep finishes and releases the process_lock, wakeup can proceed and acquire the process_lock
    and wake up the process. This mechanism is important to avoid coordination issues, including lost wakeups.


----------------------------------------------------------------
8. FILE SYSTEM
----------------------------------------------------------------
  File descriptor - abstract many Unix resources using the file system interface
  Pathname        - provide hierarchical path names & resolve them using recursive lookup
  Directory       - implement each dir as a special kind of inode
  Inode           - provide individual files (inode with unique i-number & some blocks holding the file's data)
  Logging         - wrap updates to several blocks in a transaction
  Buffer cache    - cache blocks and synchronize access to them
  Disk            - read/write blocks on virtio hard drive

----------------------------------------------------------------
9. CONCURRENCY REVISITED
----------------------------------------------------------------















